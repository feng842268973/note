#### mvvm ####

**nextTick**
>浏览器包含了浏览器主进程，第三方插件进程和GPU进程（浏览器渲染进程），其中gpu进程包括了
    - gui渲染线程
    - js引擎线程 
    - 事件触发线程（和eventLoop密切相关）
    - 定时触发器线程
    - 异步http请求线程
GUI渲染线程和js引擎线程是互斥的，其中一个执行另一个就会被挂起
和vue的nexttick相关的是js引擎线程和事件触发线程。
**双向绑定proxy和defineProperty**
proxy应该被称为*代理*，而非*劫持*，是Object.defineProperty的加强版

**vm**
Virtual DOM是对DOM的抽象，本质是js对象，这个对象是更加轻量级的对DOM的描述。
尽可能地少操作DOM，在patch过程中尽可能一次性将差异更新到DOM中。
不要盲目地区更新视图，而是通过DOM-Diff算法对比数据变化前后的状态，计算出视图哪些地方需要更新，只更新需要更新的地方。

以新的VNode为基准，改造旧的oldVNode使之成为跟新的VNode一样，这就是patch过程要做的事
**创建节点**：只有三种节点可以被创建被插入DOM，元素节点（判断是否有tag标签），文本节点，注释节点（判断isComment）
**删除节点**：在需要删除的节点的父元素上调用removeChild
**更新节点**：
    - 静态节点：新旧节点都是静态节点，直接跳过，无需处理
    - 文本节点：新节点是文本节点，如果old节点是文本节点，比较文本是否不同，不同把old节点换成跟新的文本一样，如果old节点不是文本节点，直接调用setTextNode方法把它改成文本节点，并且跟新的节点文本相同
    - 元素节点：1、新node包含子节点：看old节点是否包含子节点，如果包含，递归对比更新子节点，如果不包含，那这个old节点可能是空节点或者文本节点，如果old是空节点就把新的节点创建一份插入old节点里，如果old是文本节点，把文本清空，然后把新的节点里的子节点创建一份插入旧的节点里。2、新节点不包含子节点，同时又不是文本节点，说明是空节点，直接清空old节点。

**子节点的更新**（合适的位置是所有未处理节点之前，而不是已处理节点之后）
当新的nvode和旧的vnode都是元素节点并且包含子节点，那么他们的children就是所包含的子节点数组。循环比较他们的children，外层循环是新的vnode的children，内层是旧的。这样会产生4种情况
- 创建子节点：新的children中某个节点在旧的中找不到，说明这个新的节点是之前没有的，创建
- 删除子节点：新的vnode的children循环完毕，旧的vnode的children还有未处理的子节点，是被废弃的，删除
- 移动子节点：新的vnode的children中某个子节点在旧的中找到了，位置不同，要调整节点位置，使之跟新的vnode的children中的这个节点位置相同
- 更新节点：新的vnode的children中某个子节点在旧的中找到了与之相同的子节点，所处位置也相同，那就更新旧的children里的节点，使之与新的相同。

**子节点更新优化策略**


#### Object的变化侦测####
**在getter中收集依赖，在setter中通知依赖更新**
通过Object.defineProperty方法实现了对object数据的可观测，仅能观测到object数据的取值和设置值，当向object数据添加一堆新的key/value或者删除一对key/value，是无法观测的，无法通知依赖，也无法驱动视图更新，可以用Vue.set和Vue.delete，封装了Observer类，把object数据的所有属性都转换成getter/seter形式来侦测变化。在getter中收集依赖，在setter中通知依赖更新，封装了依赖管理器Dep，用于存储手机到的依赖，并且为每个依赖都创建了一个Watcher实例，由Watcher实例去做真实的更新操作。


其整个流程大致如下：
- Data通过observer转换成了getter/setter的形式来追踪变化。
- 当外界通过Watcher读取数据时，会触发getter从而将Watcher添加到依赖中。
- 当数据发生了变化时，会触发setter，从而向Dep中的每一个依赖（即Watcher）发送通知。
- Watcher接收到通知后，会向外界发送通知，变化通知到外界后可能会触发视图更新，也有可能触发用户的某个回调函数等。
#### Array的变化侦测####
Array型数据还是在getter中收集依赖，但是Array型数据没有setter，在Vue中创建了一个数组方法拦截器，它拦截在数组实例与Array.prototype之间，在拦截器内重写了操作数组的一些方法，当数组实例使用操作数组方法时，其实使用的是拦截器中重写的方法，而不再使用Array.prototype上的原生方法。

#### 模板编译####
编译阶段：
- 模板解析阶段：将模板字符串用正则等方式解析成抽象语法树AST
- 优化阶段：遍历AST，找到静态节点，并标记
- 代码生成阶段：将AST转换成渲染函数

#### 生命周期####
##### 初始化阶段#####
**new Vue**
合并配置，调用初始化函数，触发生命周期函数，调用$mount开启下一个阶段
**initLifecycle**
给实例初始化一些属性，包括以$开头的供用户使用的外部属性（包括$parent,$root），也包括_开头的供内部使用的内部属性
**initEvents**
初始化事件，浏览器原生的事件由父组件处理，而自定义事件是在子组件初始化的时候由父组件传给子组件，再由子组件注册到实例的事件系统中。
**initInjections**
初始化inject，inject和provide是成对出现的
**initState**
初始化实例状态，先初始化props。然后data，watch。
##### 模板编译#####
只存在于完整版本中
##### 挂载#####
创建vue实例，并用其替换el选项对应的DOM元素，同时要开启对模板中数据的监控，当数据发生变化时通知其依赖进行视图更新。

##### 销毁 #####
将当前vue实例从父级实例删除，取消当前实例的所有依赖追踪，并且移除实例上的所有事件监听器。


