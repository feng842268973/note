#### 类型转换相关 #####
1、Object类型转换为布尔值都是true，null是false,Symbol为true。

2、this的指向：
- 全局执行上下文：this指向window对象，
- 函数执行上下文：使用对象调用内部的方法，this指向对象本身
- eval执行上下文：执行eval环境内部的上两个情况

根据优先级最该的来决定this指向哪里。new的优先级最高，然后bind，apply，call，然后obj.foo,最后是foo，箭头函数的this一旦绑定，就不会被任何方式改变。

当函数作为对象的方法调用时，函数中的this就是该对象，函数被正常调用时，严格模式下，this是undefined，非严格模式this指向全局对象window。嵌套函数的this不会继承外层函数的this.

箭头函数没有自己的执行上下文，所以箭头函数的this就是外层函数的this。

3.在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。
***
#### 原型链 ####
1、每个js对象都有__proto__属性，这个属性指向了原型，原型也是一个对象，这个对象包含了很多函数。
- Object是所以对象的爸爸，所有对象都可以通过__proto__找到它，
- Function是所有函数的爸爸，所有函数都可以通过__proto__找到它，
- 函数的prototype是一个对象。foo.prototype.constructor==foo
- 对象的__proto__属性指向原型，__proto__将对象和原型链接起来组成了原型链。
***
#### v8 ####

##### 数据存储 #####
- 栈空间：先进后出的数据结构，调用栈，存储执行上下文，存储原始类型数据。
- 堆空间：用数组实现的二叉树，存储引用类型，堆空间很大，能存储很多大的数据，存放在对内存中的对象，变量实际保存的是一个指针，这个指针指向另一个位置

##### 垃圾回收 #####
为保证js的正常执行，gc和js执行不能并行执行，所以选择了类似于共享CPU时间片的执行方式，将gc和js交替执行。 

回收调用栈内的数据：执行上下文结束且没有被引用时，会通过向下移动 记录当前执行状态的指针（esp）来销毁该函数保存在栈中的执行上下文。

    V8 中会把堆分为新生代和老生代两个区域，
    - 新生代中存放的是生存时间短的对象，
    - 老生代中存放的生存时间久的对象。

垃圾回收重要术语：

    代际假说
        大部分对象在内存中存在的时间很短
        不死的对象，会活得更久
    分代收集
##### 副垃圾回收器：

主要负责新生代垃圾回收，这个区域不大，但是垃圾回收比较频繁，新生代垃圾回收算法是Scavenge算法。

这种算法的特点是：牺牲空间来提高效率，所以它的优点是执行时间短，而空间利用率不高，比较适用于体积普遍较小，生存周期补偿的新生代。

**Scavenge算法：把新生代空间对半划分为两个区域，from semispace，to semispace，当对象区域快被写满时，则会进行一次垃圾清理。

清理流程：
- 把from semispace中的垃圾做标记
- 把存活的对象复制到空闲区域，清空from semispace，（复制对象的时候，如果对象经历了多次复制，即生存周期长，v8会把它移动到老生代，如果to semispace的空间占用比例超过25%，也会把它移动到老生代，因为之后会清空from semispace，并把to semispace当成新的 from semispace，占比过高不利于后续的对象内存分配。把对象从新生代移动到老生代的过程叫晋升。）
- 把这些对象有序地排列起来
- 清理完后，from semispace与to semispace互换。

**mark-sweep算法**（标记-清除算法）：
    另一种普遍的算法，jvm采用了这种算法，该算法遍历当前堆内的所有对象，把死亡的对象进行标记，然后进行一次清理。
    
    这样做的坏处在于，遍历整个堆耗时，相对于scavenge算法，scavenge算法只遍历了半个堆，相对耗时较短，mark-sweep遍历整个堆，耗时较长。
    
    除此，还有个缺点是被清除的对象使原本完整的堆变成了堆碎片。被清理掉的对象在堆中留下空洞，这样的可怕之处在于：下一次为大对象分配空间时，由于堆碎片不连续，无法分配给这个大对象空间 ，会提前触发GC，这次GC是不必要的，为了弥补这种算法带来的问题，提出了mark-compact（标记-整理）算法。它的作用是将存活的对象向一个方向移动，把不连续的堆碎片变完整。
    
    由此可见，mark-sweep需要配合mark-compact算法才能很好地进行GC，整个过程相比scavenge算法较长，但是空间利用率更大，所有这种算法适合不需要频繁GC的老年代。
>2、主垃圾回收器：
主要负责老生代中的垃圾回收。

除了新生代中晋升的对象，一些大的对象会直接被分配进老生代。

    因此老生代中的对象有两个特点：
    - 对象占用空间大，
    - 对象存活时间长。

这里用的算法就是mark-sweep算法。

>3、一旦执行垃圾回收算法，会导致全停顿。

但是v8有增量标记法，可以将上述步骤拆成更细的粒度，让回收中的标记阶段和应用逻辑交替进行，v8引入这个方式后，最大停顿减少到原来的1/6.
#### 事件循环 ####
-微任务：
    - process.nextTick
    - promise
    - MutationObserve
-宏任务：
    - script
    - setTimeout
    - setInterval
    - setImmediate
    - I/O
    - UI rendering

3、执行顺序：
- 执行同步代码，这属于宏任务
- 执行栈为空，查询是否有微任务需要执行
- 必要的话渲染ui
- 开始下一轮event loop，执行宏任务中的异步代码

#### 浏览器安全 ####
1、攻击方式：
- xss（跨站脚本漏洞）：将代码注入到网页
    - 持久型：写入数据库
    - 非持久型：修改用户代码
- csrf（跨站请求伪造）：攻击者虚构一个请求地址，引导用户通过某些途径发送请求。
中间人攻击：攻击方同时与服务端和客户端简历连接，并让对方认为是安全的。攻击者不仅能获得双方通信息，还能修改通信信息。
    - dns欺骗：入侵dns将用户访问目标改为入侵者指定机器。
    - 会话劫持：在一次正常通信过程中，攻击者作为第三方参与其中，或者在数据中加入其他信息，将双方的通信模式暗中改变，从直接联系变成有攻击者参与的联系。

2、预防措施：
- xss：
  - 转义字符过滤html代码
    ```javascript
    const escapeHTML = value => {
        if (!value || !value.length) {
            return value;
        }
        return value
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#39;");
        };
    ```
  - 过滤sql代码
    ```
    const replaceSql = value => {
    if (!value || !value.length) {
        return value;
    }
    return value.replace(/select|update|delete|exec|count|'|"|=|;|>|<|%/gi, "");
    };
    ```
- csrf:
    - 验证http referer字段(引用来源，告诉服务器网页是从哪里来的)
    - 请求地址中添加token并验证
    - 在http头中自定义属性并验证
    - get请求不对数据进行修改（GET HTTP请求不应该改变状态，它们应该是幂等的。幂等性意味着发出一次请求或多次发出请求会得到相同的结果。即没有副作用）
    - 接口防跨域处理
    - 不让第三方网站访问用户cookie（same-site）
- 预防中间人攻击
    - dns欺骗：检查本机hosts文件
    - 会话劫持：使用交换式网络代替共享式网络，还必须使用静态arp（地址解析协议），捆绑mac+ip等方式限制欺骗，以及采用认证方式的连接等
- 内容安全策略（csp）
    内容安全策略是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本xss和数据注入攻击等，这些攻击是主要的手段。
    > <meta http-equiv="Content-Security-Policy">

    > HTTP Header 中的 Content-Security-Policy

#### 浏览器相关 ####
- dns预解析
- 强缓存
![缓存机制](https://github.com/feng842268973/note/tree/master/src/images/cache.jpg)